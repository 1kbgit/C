==============================================================================

Makefile有五部分
----------------

Makefile		顶层的Makefile文件.
.config			配置kernel后在目录根生成的配置文件.
arch/$(ARCH)/Makefile	架构Makefile文件.
scripts/Makefile.*	包含了与一般编译,模块生成,各种实用程序的编译,从内核树
			删除目标文件和临时文件等任务相关的make规则.
kbuild Makefiles	内核源代码的各个子目录都包含了与特定驱动程序或子系统相
			关的Makefile.

顶层的Makefile文件读取从配置过程生成的总配置文件.config.
顶层的Makefile主要负责编译vmlinux(常驻内核镜像)和模块(任何的模块文件).
顶层的Makefile通过递归的访问内核目录树的子目录来构建那些目标.
构建那些目标时需要访问的子目录列表依赖于内核的配置文件.config.
顶层的Makefile文本上包括了一个在arch/$(ARCH)/Makefile的架构Makefile文件,这个架
够Makefile文件向顶层的Makefile提供了具体的架构信息.


makefile的作用
--------------

在一个kernel中这样的大工程中,如何去编译这个工程?应该make,是的.为什么一条make命
令就能够做到?其实make命令的背后是许多的makefile在为make命令出谋划策,makefile作
为路线图指导make编译的每一个步骤.

make是一个命令工具,是一个解释makefile文件中指令的命令工具.make作为makefile这个
语法文件的解释器在工作.makefile的语法是一种在工程方面的编译方法,以告诉make命令
需要怎样去编译和链接目标程序.

makefile给这个大工程带来的是自动化编译kernel.


makefile规则介绍
----------------

目标文件... : 依赖文件...
	命令
	...
	...

目标文件的生成依赖于其它的文件,按照规则执行相应的命令就能够生成目标文件所需的
依赖文件.

makefile规则中,如果使用一个没有依赖只有命令行的双冒号规则去更新一个文件,那么每
次执行make时,此规则的目标文件将会被无条件的更新(即此规则定义的命令会被无条件执
行).

通常我们在工程中会遇到,其中一个(makefile-A)需要使用另外一个(makefile-B)中所定
义的变量和规则.这时候用include(用来包含其它文件)并不保险,因为这两个文件可能存
在规则重复定义的问题.如下可解决问题:

#sample GUNmakefile
foo:
	frobnicate > foo
%:force
	@$(MAKE) -f Makefile $@
force:;


makefile清除规则
----------------

清除当前目录中编译过程中产生的临时文件的规则

clean :
	rm edit $(objects)

也可以如下这样写让清除工作不会出现任何差错

.PHONY : clean
clean :
	-rm edit $(objects)

有两个不同点:
1)通过.PHONY特殊目标将clean目标声明为伪目标.避免当磁盘上存在一个名为clean文件
时,目标clean所在的规则的命令无法执行.
2)在命令之前使用"-",意思是忽略命令rm的执行错误.

这样的一个目标在makefile中,不能将其作为终极目标(makefile的第一个目标).因为我们
的初衷并不是在命令行上输入make以后执行删除动作,而是要创建或者更新程序.


make如何解析makefile文件
------------------------

分为两个阶段

第一阶段:读取所有的makefile文件(包括指示符"include"指定的,以及命令行选项"-f"指
定的makefile文件),内建所有的变量,明确规则和隐含规则,并建立所有目标和依赖之间的
依赖关系结构链表.

第二阶段:根据第一阶段已经建立的依赖关系结构链表决定哪些目标需要更新和创建,并使
用对应的规则来重建这些目标.


==============================================================================
==============================================================================
