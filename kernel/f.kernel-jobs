==============================================================================

内核任务
--------


内核是hi硬件与软件之间的一个中间层。其作用是将应用程序的请求传递给硬件，并充当
底层驱动程序，对系统中的各种设备和组件进行寻址。

从应用程序的视角来看，应用程序朱旭发送传输数据的命令。实际的工作如何完成与应用
程序是不相干的，因为内核抽象了相关的细节。应用程序与硬件本身没有联系，至于内核
有联系，内核是应用程序所知道的层次结构中最底层。

当若干程序在统一系统中并发运行时，也可以将内核视为资源管理程序。在这种情况下，
内核负责将可用共享资源（包括CPU时间，磁盘空间，网络连接等）分配到各个系统进程，
同时还需要保证系统的完整性。


内核种类
--------


微内核：只有最基本的功能直接有中央内核（即微内核）实现。所有其他的功能都委托给
一些独立进程，这些进程通过明确定义的通信接口与中心内核通信。如，独立进程可能负
责实现各种文件系统，内存管理等。

宏内核：内核的全部代码，包括所有子系统（如内存管理，文件系统，设备驱动程序）都
打包到一个文件中。内核中的每个函数都可以访问内核中所有其他部分。linux便是采用
宏内核的方式，但在系统运行中，模块可以插入到内核代码中，也可以移除，这使得可以
向内核动态添加功能，弥补了宏内核的一些缺陷。


进程
----


由于Linux是多任务系统，它支持（看上去）并发执行的若干进程。系统中同时真正在运
行的进程数目最多不超过CPU数目，因此内核会按照短的时间间隔在不同的进程之间切换
（用户是注意不到的）。内核借助于CPU的帮助，负责进程之间进行切换。内核还必须确
定如何在在现存进程之间共享CPU时间。重要进程得到的CPU时间多一点，次要进程得到的
少一点，确定那个进程运行多长时间的过程称为调度。

linu对进程采用了一种层次系统，每个进程都依赖于一个父进程。内核启动init程序作为
第一进程，该进程负责进一步的系统初始化操作，因此init是进程树的根，所有的进程都
直接或间接起源自该进程。

创建新进程的两种机制：fork和exec

fork可以创建当前进程的一个副本，父进程和子进程只有PID（进程ID）不同。linux使用
了一种叫做写时复制（copy on write）的级数来是fork操作更高效，主要的原理是将内
存复制操作延迟到父进程或子进程向某内存页面写入数据之前，在只读访问的情况下父进
程和子进程可以公用同一内存页。

exec是将一个新程序加载到当前进程的内存中并执行。旧程序的内存页将刷出，其内容将
替换为新的数据。然后开始执行新程序。

线程：本质上一个进程可能有若干线程组成，这些线程共享同样的数据和资源，但可能执
行程序中不同的代码路径。线程通常也称为轻量级进程。

linux用clone方法创建线程。其工作方式类似与fork，但启用了精确的检查，以确认哪些
资源与父进程共享，哪些资源为线程独立创建。这种细粒度的资源分配扩展了一般的线程
概念，在一定成都上允许线程与进程之间的连续转换。

命名空间：linux中对命名空间的支持被集成到了许多子系统中。这使得不同的进程可以
看到不同的系统视图。如linux进程ID中有唯一表示的全局变量，启用命名空间之后，以
前的全局资源可以具有不同的分组。每个命名空间可以包含一个特定的PID集合，或可以
提供文件系统的不同视图，在某个命名空间中挂载的卷不会传播到其他命名空间中。现在
最大的用处莫过于在容器上的应用了，人们不必在为每个用户准备一台物理计算机，而是
通过称为容器的命名空间建立系统的多个视图。从容器内部看来这是一个完整的linux系
统，而且与其他容器没有交互，这样事实上一台物理机器可以同时运转许多这个的容器实
例，有助于更有效地使用资源。与完全虚拟化解决方案（如KVM）相比，计算机上只需要
运行一个内核来管理所有的容器。


内存管理
--------


地址空间的最大长度与实际可用的物理内存数量无关，这被称为虚拟地址空间。

2^10byte=1Kib 2^20byte=1Mib 2^30byte=1Gib 
由于内存区域是通过指针寻址，因此对于32位系统是2^32byte=4Gib，对64位是2^64byte。

linux将虚拟地址空间划分为两个部分，分别称为内核空间和用户空间。
0到TASK_SIZE是用户进程的虚拟地址范围。
TASK_SIZE到2^32或2^64是内核空间。
TASK_SIZE是一个特定与计算机体系结构的常数，如对于32位系统能够寻址的虚拟地址空
间为4Gib，TASK_SIZE常数是3Gib处，用户空间为0-3Gib，内核空间为3-4Gib。这种划分
与可用的内存数量无关。由于地址空间虚拟化的结果，每个用户进程都认为自身有3Gib的
内存，各个系统进程的用户空间是完全彼此分离的，而虚拟地址空间顶部的内核空间总是
同样的，这样内核的地址空间总是不会和用户地址空间混在一起，这样用户态和内核态之
间的分离的这种机制可防止进程无意间修改彼此的数据而造成相互干扰。

从用户状态到核心态的切换通过系统调用的特定手段完成。
普通进程只能借助于系统调用向内核发出请求，内核首先检查进程是否允许执行想要的操
作，然后代表进程执行所需的操作，接下来返回到用户状态。

虚拟地址如何映射到物理地址上呢？一一对应，显然不行。
内核将地址空间划分为很多等长的部分，这些部分称之为页。这样虚拟地址空间和物理地
址空间都能够用同样大小的页来表示，通过页来产生一一对应的关系，这样虚拟地址空间
就能和物理地址空间映射到一起。由于内核负责将虚拟地址空间映射到物理地址空间，因
此可以决定那些内存区域在进程之间共享，那些不共享，这样在内核的管控下，内核空间
和用户空间的进程内存仍然是分离的，不会造成混乱。

用来将虚拟地址空间映射到物理地址空间的数据结构称为页表。为减少页表的大小并容许
忽略不需要的区域，linux将虚拟地址划分成几部分，采用四级页表的管理方式，如同用
树形的数据结构可以快速寻找到自己所需要的内存块，如果你知道算法是怎么一回事的话，
这里应该很容易理解，如果有困难的话，自己做一下功课，这里不打算展开讲。

每次访问内存时，必须逐级访问多个数组才能将虚拟地址转换为物理地址，CPU则使用如
下的方法来加速该过程：
1）CPU中有一个专门的部分称为MMU（Memory Management Unit，内存管理单元），该单
元优化了内存访问操作。
2）地址转换中出现最频繁的那些地址，保存到称为地址转换后备缓冲器（TLB）的CPU高
速缓存中。无需访问内存中的页表即可从高速缓存直接获得地址数据。

内核在实现设备驱动程序时直接使用了内存映射。外设的输入/输出可以映射到虚拟地址
空间的区域中。对相关内存区域的读写会由系统重定向到设备，因而大大简化了驱动程序
的实现。

伙伴系统：内核中很多时候要求分配连续页。为快速检测内存中的连续区域，内核使用了
一种叫做伙伴系统。
系统中的空闲内存块总是两两分组，每组中的两个内存块称为伙伴。伙伴的分配可以是彼
此独立的。但如果两个伙伴都是空闲的，内核会将其合并为一个更大的内存块，作为下一
层上某个内存块的伙伴。
内核对所有大小相同的伙伴，都防止到同一个列表中管理。
例如：如果系统想在需要8个页帧，则将16个页帧组成的块拆分为两个伙伴。其中一块用
与满足应用程序的请求，而剩余的8个页帧则放置到对应8页大小内存块的列表中。

slab缓存：伙伴系统作为一种在使用比页帧大的内存的一种解决办法，但是，内核本身经
常需要比完整页帧小的多的内存块时就是一个问题了。这时，内核将伙伴系统提供的页划
分为更小的部分，还对频繁使用的小对象实现了一个一般性的缓存（slab缓存）。
slub则是slab的一个替代品，但是slub完全兼容slab。slub的效率更高更简单。

页面交换：页面交换通过利用磁盘空间作为扩展内存，从而增大了可用的内存。在内核需
要更多内存时，不经常使用的页可以写入硬盘，如果再需要访问相关数据，内核会将相应
的页切换回内存。

页面回收用于将内存映射被修改的内容与底层的块设备同步，有时也称为数据回写。


==============================================================================
==============================================================================
