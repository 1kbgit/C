==============================================================================

中断（IRQ）和计时器（timer）
----------------------------


中断（IRQ）和计时器（timer）是不是内核的标准工作组件呢？当然是的。为什么不将其
和内核的其他组件放在一起来讨论呢？因为我觉得中断和计时器比起其他的组件更特殊。

首先，这两者都是比较偏向于内核的底层，更直接的与硬件接触，也就是说他们更依赖于
CPU，比如CPU周围通过总线交互的一些外设（键盘，鼠标...）都是通过硬中断实现的。
其次，内核的其他组件基本上都要依赖于这两个组件，比如像进程管理，驱动程序开发等
等这样的内核组件都依赖这两个组件。


中断（IRQ）
-----------


两种类型的中断：硬件中断和软中断。

硬件中断（hardware interrupt）：由系统自身和与之连接的外设自动产生。他们用于支
持更高效地实现设备驱动程序，也用于引起处理器自身对异常或错误的关注，这些是需要
与内核代码进行交互的。
与内核的其他部分相比，用于处理中断和系统调用相关部分的代码中，汇编和C代码交织
在一起，以解决C语言无法独立处理的一些微妙问题。在内核的中断部分中，高层代码和
底层的硬件交互代码，已经尽可能有效而干净地分隔开了。

软中断（SoftIRQ）：用于有效实现内核中的延期操作。
内核中经常需要一些机制，将某些活动延迟到未来的某个时间执行，或将活动置于某个队
列（tasklet）上，在时间充裕时进行后续处理。


在linux中有一个用于中断和IRQ的通用框架，linux所支持的各种平台只负责在最低层次
上与硬件交互。所有其他功能都由通用代码提供。

硬件中断不能由处理器外部的外设直接产生，而必须借助于一个称为中断控制器的标准组
件来请求。中断外部设备会有电路连接到用于中断控制器发送中断请求的组件。中断控制
器就是一个控制电路，好了，这里涉及了电路设计的问题，不打算深入电路设计的内部，
如果你有兴趣的话，可以看看关于通用计算机体系设计，如CPU，内存，总线，外设，尤
其像CPU的设计里面的控制电路不胜枚举，扯远了。

中断处理的过程：中断现行程序，转到中断服务程序处执行，回到被中断的程序继续执行。


　　　　　　　　　｜CPU收到中断信号
正在运行的程序　　ｖ
——————————————————》　　　　　　　　　　————————————————————————》
　　　　　　　　　｜　　　　　　　　　＆　中断服务程序执行结束
　　　　　　　＋——————＋　　　　　　　｜　返回继续执行元程序
　　　　　　　｜ 中断 ｜　　　　　＋—————————＋　　
　　　　　　　＋——————＋　　　　　｜中断返回 ｜
　　　　　　　　　｜　　　　　　　＋—————————＋
　　　　　　　　　ｖ　　　　　　　　　｜
　　　　　　　　　　——————————————————》
　　　　　　　　　　CPU中断正在执行的程序
　　　　　　　　　　转到执行中断服务程序


这些中断处理过程中涉及了CPU中的寄存器操作，这些操作只能由汇编语言来完成了。

　　　中断　　　　　　　　　　　　　　　　　＋————————————————————————————＋
　　　　｜　　　　　　　　　　　　　　　　　｜有必要　　　　　　　　　　　｜
　　　　ｖ　　　　　　　　　　　　　　　　　｜进行调度？－－》调度　　　　｜
＋————————————————＋　　　　　　　　　　　　｜　｜　　　　　　　　　　　　｜
｜　切换到内核栈　｜　　　　　　　　　　　　｜　ｖ　　　　　　　　　　　　｜
｜　　　｜　　　　｜　　＋————————————＋　　｜　信号－－》将信号投递到进程｜
｜　　　ｖ　　　　｜－》｜中断处理程序｜－》｜　｜　　　　　　　　　　　　｜
｜　保存寄存器　　｜　　＋————————————＋　　｜　ｖ　　　　　　　　　　　　｜
＋————————————————＋　　　　　　　　　　　　｜恢复寄存器　　　　　　　　　｜
　　　　　　　　　　　　　　　　　　　　　　｜　｜　　　　　　　　　　　　｜
　　　　　　　　　　　　　　　　　　　　　　｜　ｖ　　　　　　　　　　　　｜
　　　　　　　　　　　　　　　　　　　　　　｜激活用户栈　　　　　　　　　｜
　　　　　　　　　　　　　　　　　　　　　　＋————————————————————————————＋
　　　　　　　　　　　　　中断的处理过程

在软中断的基础之上，实现了tasklet和工作队列机制，这两种机制是内核对可延迟中断
处理的支持。

他们的特点为：
tasklet在软中断之上实现。
在同一个CPU上软中断/tasklet不嵌套。
tasklet是并行可执行，同类tasklet不能并发。
软中断由内核静态分配，tasklet可以在运行时分配和初始化。
软中断/tasklet不能睡眠，阻塞，工作队列以内核线程身份运行。

可延迟函数上可以执行4种操作：
初始化：定义一个新的可延迟函数，通常在内核初始化时进行。
激活：设置可延迟函数在下一轮处理中执行。
屏蔽：有选择的屏蔽一个可延迟函数，这样即使被激活也不会被运行。
执行：在特定的时间执行可延迟函数。

有了软中断之上的tasklet和工作队列机制的更高抽象，这样便可以面向内核的其它组件，
例如：进程的调度，时钟，网络，驱动程序（网络及驱动的中断和硬件中断相比他们在更
高抽象层次）。


==============================================================================
